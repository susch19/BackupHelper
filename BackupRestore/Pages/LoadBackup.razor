@page "/restore"
@using Backup.Shared
@using BackupRestore.Data;
@using System.Text;
@using Radzen.Blazor;
@using System.Text.RegularExpressions;
@using static System.Net.WebRequestMethods;
@inject RecoveryService RecoveryService

<PageTitle>Restore</PageTitle>

<h1>Restore</h1>

@if (fileInfos.Count < 1)
{
    <div class="metadata-select">
        <button @onclick="SelectFilePath">Select Metadata File</button>
        <div />
        <InputText @bind-Value="filePath"></InputText>
        @*<InputFile OnChange="@OnInputFileChange" accept=".metadata.zip.aes" />*@
    </div>

    <div class="row">
        <InputText @bind-Value="Password" type="password" placeholder="Password" />
    </div>
    <button class="row" type="submit" @onclick="LoadData">Load</button>
}
else if (storeView)
{
    <div class="store-grid">
        <div>
            <span>Speicherpfad:</span>
        </div>
        <div>
            <InputText @bind-Value="dirPath" />
        </div>
        <div>
            <button @onclick="SelectDirPath">Select</button>
        </div>
        <div>
            <button @onclick="SaveBackup" disabled="@(string.IsNullOrWhiteSpace(dirPath) ? true : false)">Restore</button>
        </div>
        <div>
            <button @onclick="Reset">Start over</button>
        </div>

    </div>
    <Virtualize Context="context" ItemsProvider="@GetNodes" @ref="virtualizeComponent">
        <ShowItem Item=@context @key="context.node.FullPath">
            <div style="display: grid; grid-template-columns: 1em max-content 1em max-content; margin-left: @(context.level * 20)px">
                <svg viewBox="0 0 16 16" style="margin-top: 0.3rem;height: 1em; vertical-align: middle; transform: rotate(@(context.node.IsExpanded ? 90 : 0)deg); @(context.node.Children.Any() ? "cursor: pointer" : "")" @onclick="() => ChangeNode(context.node)" @onclick:stopPropagation>
                    <path d="M 4 2 l 7 6 l -7 6" stroke="@(context.node.Children.Any() ? "white" : "transparent")" fill="transparent" stroke-width="2" />
                </svg>
                <RadzenLabel Text="@context.node.Name" Style="margin-left: 8px; vertical-align: middle;" />
                <div />
                <div style="visibility:@(context.node.HistoryFileSelected == ushort.MaxValue ? "hidden" : "visible")">
                    @if (context.node.HistoryFileSelected != ushort.MaxValue)
                    {
                        @fileNameIndex.Index[context.node.HistoryFileSelected].CreateDate.ToShortDateString()
                    }
                </div>
            </div>
        </ShowItem>
    </Virtualize>
}
else
{
    <div class="toolbox-grid">
        <RadzenButton Click="()=>{ storeView = true; }" Text="Save" />
        <div></div>
        <RadzenButton Click="()=>{ fileInfos.Clear(); }" Text="Load" />
    </div>
    <br />
    <div class="search-toolbox">
        <RadzenTextBox @bind-Value="filter" />
        <div />
        <RadzenCheckBox @bind-Value=fullTextSearch TValue="bool" @onclick:stopPropagation />
        <RadzenLabel Text="FullTextSearch" Style="margin-left: 8px; vertical-align: middle;" />
        <div />
        <RadzenButton Click="()=>{ Search(); }" Text="Search" />
        <div />
        <RadzenButton Click="()=>{ ClearFilter();  }" Text="Clear" />
    </div>
    <br />

    <Virtualize Context="context" ItemsProvider="@GetNodes" @ref="virtualizeComponent">
        <ShowItem Item=@context @key="context.node.FullPath">
            <div style="display: grid; grid-template-columns: 1em 1em max-content 1em max-content; margin-left: @(context.level * 20)px">
                <svg viewBox="0 0 16 16" style="margin-top: 0.3rem;height: 1em; vertical-align: middle; transform: rotate(@(context.node.IsExpanded ? 90 : 0)deg); @(context.node.Children.Any() ? "cursor: pointer" : "")" @onclick="() => ChangeNode(context.node)" @onclick:stopPropagation>
                    <path d="M 4 2 l 7 6 l -7 6" stroke="@(context.node.Children.Any() ? "white" : "transparent")" fill="transparent" stroke-width="2" />
                </svg>
                <RadzenCheckBox @bind-Value=@context.node.IsSelected TValue="bool" @onclick:stopPropagation />
                <RadzenLabel Text="@context.node.Name" Style="margin-left: 8px; vertical-align: middle;" />
                <div />
                <div style="visibility:@(context.node.BackupFileIndeces.Count == 0 ? "hidden" : "visible")">
                    <InputSelect @bind-Value="context.node.HistoryFileSelected">
                        @foreach (var item in context.node.BackupFileIndeces)
                        {
                            <option value="@item">@fileNameIndex.Index[item].CreateDate.ToShortDateString()</option>
                        }
                    </InputSelect>
                </div>
            </div>

        </ShowItem>
    </Virtualize>
}

@code {

    private string Password { get; set; }

    private List<FileDisplayInfo> fileInfos = new();
    private List<(FileDisplayInfo node, int level)> flatFileInfos = new();
    private BackupFileNameIndex fileNameIndex = new();
    private Virtualize<(BackupRestore.Data.FileDisplayInfo, int)>? virtualizeComponent;

    private string dirPath = "";
    private string filePath = "";

    private string filter = "";
    private bool fullTextSearch = false;
    private Regex? filterRegex = null;
    private bool storeView = false;
    (BackupRestore.Data.FileDisplayInfo node, int level)[]? arr;

    private void Search()
    {
        filterRegex = new Regex(filter);
        ChangeTreeView();
    }
    private void ClearFilter()
    {
        filterRegex = null;
        filter = "";
        ChangeTreeView();
    }
    private void Reset()
    {
        storeView = false;
        filter = "";
        fileInfos.Clear();
        flatFileInfos.Clear();
        fileNameIndex = new();
    }

    private void SelectFilePath()
    {
        filePath = RecoveryService.GetFilePath("metadata.zip.aes");
    }
    private void SelectDirPath()
    {
        dirPath = RecoveryService.GetDirectoryPath();
    }

    private async Task LoadData()
    {

        if (string.IsNullOrWhiteSpace(filePath))
            return;

        storeView = false;
        (fileNameIndex, fileInfos) = RecoveryService.GetBackupInformation(filePath, Password);
        GenerateFlatList();
        await ChangeTreeView();
    }

    private async Task ChangeTreeView()
    {
        if (filterRegex is null)
            arr = flatFileInfos
            .Where(x =>
                (x.node.Parent is null || x.node.Parent.IsExpanded)
                && (!storeView
                    || (x.node.IsSelected || x.node.AnyChildSelected)))
            .ToArray();
        else
            arr = flatFileInfos
                .Where(x => !storeView && FileDisplayInfo.Matches(x.node, filterRegex, fullTextSearch))
                .ToArray();
        var virtComp = virtualizeComponent;
        if (virtComp is not null)
            await virtComp?.RefreshDataAsync();
    }

    private ValueTask<ItemsProviderResult<(BackupRestore.Data.FileDisplayInfo node, int level)>> GetNodes(ItemsProviderRequest request)
    {
        var localArr = arr;
        if (localArr is null)
            localArr = Array.Empty<(BackupRestore.Data.FileDisplayInfo node, int level)>();

        //arr = flatFileInfos.Where(x => MemoryExtensions.Contains(x.node.Name, filter, StringComparison.OrdinalIgnoreCase)
        //|| (MemoryExtensions.Contains(x.node.FullPath, filter, StringComparison.OrdinalIgnoreCase)
        //    && (x.node.Parent is null || x.node.Parent.IsExpanded))).ToArray();

        var items = localArr.Skip(request.StartIndex).Take(request.Count);

        return new(new ItemsProviderResult<(BackupRestore.Data.FileDisplayInfo, int)>(
            items,
            localArr.Length));
    }


    private void GenerateFlatList()
    {
        flatFileInfos.Clear();
        foreach (var node in fileInfos)
        {
            Stack<(FileDisplayInfo node, int level)> stack = new();
            stack.Push((node, 0));

            while (stack.Count > 0)
            {
                (FileDisplayInfo node, int level) current = stack.Pop();
                flatFileInfos.Add(current);
                if (!current.node.Children.Any())
                    current.node.HistoryFileSelected = current.node.BackupFileIndeces.Last();

                for (int i = current.node.Children.Count - 1; i >= 0; i--)
                {
                    stack.Push((current.Item1.Children[i], current.level + 1));
                }
            }
        }
    }

    private async Task SaveBackup()
    {
        await RecoveryService.RestoreFiles(dirPath, Password, flatFileInfos.Select(x => x.node).Where(x => x.IsSelected && !x.Children.Any()).ToArray(), fileNameIndex);

    }
    private async Task ChangeNode(FileDisplayInfo node)
    {
        node.IsExpanded = !node.IsExpanded;
        await ChangeTreeView();
    }

}
