@page "/restore"
@using BackupRestore.Data;
@using Backup.Shared
@using System.Text;
@using Radzen.Blazor;
@using static System.Net.WebRequestMethods;
@inject RecoveryService RecoveryService

<PageTitle>Restore</PageTitle>

<h1>Restore</h1>


@if (fileInfos.Count < 1)
{
    <div class="row">
        <InputFile OnChange="@OnInputFileChange" accept=".metadata.zip.aes" />
    </div>
    <div class="row">

        <InputText @bind-Value="Password" type="password" placeholder="Password" />
    </div>
    <button class="row" type="submit" @onclick="LoadData">Load</button>
}
else
{
    <div class="toolbox row">
        <RadzenButton Click="()=>{ }" Text="Save" />
        <div></div>
        <RadzenButton Click="()=>{ fileInfos.Clear(); }" Text="Load" />
    </div>
    <div>
        @*<RadzenTextBox Placeholder="Search..." Change=@(args => { filter = args; virtualizeComponent?.RefreshDataAsync(); }) />*@
    </div>
    <Virtualize Context="context" ItemsProvider="@GetNodes" @ref="virtualizeComponent">
        <ShowItem Item=@context @key="context.node.FullPath">
            <div style="display: grid;grid-template-columns:1em 1em max-content 1em;margin-left: @(context.level * 20)px">
                <svg viewBox="0 0 16 16" style="margin-top: 0.3rem;height: 1em; vertical-align: middle; transform: rotate(@(context.node.IsExpanded ? 90 : 0)deg); @(context.node.Children.Any() ? "cursor: pointer" : "")" @onclick="() => ChangeNode(context.node)" @onclick:stopPropagation>
                    <path d="M 4 2 l 7 6 l -7 6" stroke="@(context.node.Children.Any() ? "black" : "transparent")" fill="transparent" stroke-width="2" />
                </svg>
                <RadzenCheckBox @bind-Value=@context.node.IsSelected TValue="bool" @onclick:stopPropagation />
                <RadzenLabel Text="@context.node.Name" Style="margin-left: 8px; vertical-align: middle;" />
                <div></div>
            </div>

        </ShowItem>
    </Virtualize>
}

@code {
    private List<FileDisplayInfo> fileInfos = new();
    private List<(FileDisplayInfo node, int level)> flatFileInfos = new();
    private BackupFileNameIndex fileNameIndex = new();
    private Virtualize<(BackupRestore.Data.FileDisplayInfo, int)>? virtualizeComponent;

    private string Password { get; set; }
    private string filter = "";

    IBrowserFile? selectedFile;

    private List<string> Items = new List<string>
{
        "1",
        "1.1",
        "1.2",
        "2",
        "3",
        "3.1",
        "3.1.1",
        "3.1.2"
    };
    private string GetParent(string item)
    {
        var last_period = item.LastIndexOf('.');
        if (last_period < 0)
        {
            return null; // no parent
        }
        else
        {
            return item.Substring(0, last_period);
        }
    }

    private void OnInputFileChange(InputFileChangeEventArgs e)
    {
        selectedFile = e.File;

    }

    private async Task LoadData()
    {
        if (selectedFile is null || selectedFile.Size < 1)
            return;

        Stream stream = selectedFile.OpenReadStream(512000000);
        using MemoryStream ms = new MemoryStream();
        await stream.CopyToAsync(ms);

        var uploadedFile = new MetaDataFileUpload();
        uploadedFile.FileName = selectedFile.Name;
        uploadedFile.FileContent = ms.ToArray();
        selectedFile = null;
        (fileNameIndex, fileInfos) = RecoveryService.GetBackupInformation(uploadedFile, Password);
        GenerateFlatList();
    }

    private ValueTask<ItemsProviderResult<(BackupRestore.Data.FileDisplayInfo node, int level)>> GetNodes(ItemsProviderRequest request)
    {
        (BackupRestore.Data.FileDisplayInfo node, int level)[] arr;
        if (string.IsNullOrWhiteSpace(filter))
            arr = flatFileInfos.Where(x => (x.node.Parent is null || x.node.Parent.IsExpanded)).ToArray();
        else
            arr = flatFileInfos.Where(x => MemoryExtensions.Contains(x.node.Name, filter, StringComparison.OrdinalIgnoreCase)
                || (MemoryExtensions.Contains(x.node.FullPath, filter, StringComparison.OrdinalIgnoreCase)
                    && (x.node.Parent is null || x.node.Parent.IsExpanded))).ToArray();

        var items = arr.Skip(request.StartIndex).Take(request.Count);

        return new(new ItemsProviderResult<(BackupRestore.Data.FileDisplayInfo, int)>(
            items,
            arr.Length));
    }


    private void GenerateFlatList()
    {
        flatFileInfos.Clear();
        foreach (var node in fileInfos)
        {
            Stack<(FileDisplayInfo node, int level)> stack = new();
            stack.Push((node, 0));

            while (stack.Count > 0)
            {
                (FileDisplayInfo node, int level) current = stack.Pop();
                flatFileInfos.Add(current);

                for (int i = current.node.Children.Count - 1; i >= 0; i--)
                {
                    stack.Push((current.Item1.Children[i], current.level + 1));
                }
            }
        }
    }


    private async Task ChangeNode(FileDisplayInfo node)
    {
        node.IsExpanded = !node.IsExpanded;
        await virtualizeComponent?.RefreshDataAsync();
    }

    private string GenerateHtml(List<FileDisplayInfo> files, int i = 0)
    {
        StringBuilder sb = new();
        string pre = string.Join("", Enumerable.Repeat(' ', i * 4)) + ">";
        foreach (var item in files)
        {

            sb.Append("<div >");
            sb.Append(pre);
            sb.Append(item.Name);
            sb.Append("</div><br/>");
            sb.Append(GenerateHtml(item.Children, i + 1));

        }
        return sb.ToString();
    }

}
